<head>
    <title>Not a music game</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; color: white }
        canvas { display: block; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #collisionCount {
            position: absolute;
            top: 10px;
            right: 10px;
            color: yellow;
            font-size: 24px;
            font-family: Arial, sans-serif;
            z-index: 10;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="ui">
        <input type="file" id="audioFile" accept=".mp3, .wav">
        <div id="collisionCount">Collisions: 0</div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
class ZeroTime
{   s() { return 0; }
}

class AudioTime{
	constructor(audio) { this.audio = audio; }

	s() { return this.audio.currentTime; }
}

let time = new ZeroTime();

function rand(min, max) { return min + Math.random() * (max - min); }

function clamp(v, min, max) {
	if(v < min) return min;
	if(v > max) return max;
	return v;
}

function HSVtoRGB(h, s, v) {
	var r, g, b, i, f, p, q, t;
	if (arguments.length === 1) {
		s = h.s, v = h.v, h = h.h;
	}
	i = Math.floor(h * 6);
	f = h * 6 - i;
	p = v * (1 - s);
	q = v * (1 - f * s);
	t = v * (1 - (1 - f) * s);
	switch (i % 6) {
		case 0: r = v, g = t, b = p; break;
		case 1: r = q, g = v, b = p; break;
		case 2: r = p, g = v, b = t; break;
		case 3: r = p, g = q, b = v; break;
		case 4: r = t, g = p, b = v; break;
		case 5: r = v, g = p, b = q; break;
	}
	return {r: r, g: g, b: b};
}

function fft(real, imag) {
	const n = real.length;
	if ((n & (n - 1)) !== 0) throw new Error("FFT length must be a power of 2");

	let j = 0;
	for (let i = 1; i < n; i++) {
		let bit = n >> 1;
		while (j >= bit) { j -= bit; bit >>= 1; }
		j += bit;
		if (i < j) {
			[real[i], real[j]] = [real[j], real[i]];
			[imag[i], imag[j]] = [imag[j], imag[i]];
		}
	}

	for (let len = 2; len <= n; len <<= 1) {
		const ang = -2 * Math.PI / len;
		const wlenReal = Math.cos(ang), wlenImag = Math.sin(ang);
		for (let i = 0; i < n; i += len) {
			let wReal = 1, wImag = 0;
			for (let k = 0; k < len / 2; k++) {
				const uReal = real[i + k + len / 2], uImag = imag[i + k + len / 2];
				const tReal = uReal * wReal - uImag * wImag;
				const tImag = uReal * wImag + uImag * wReal;
				real[i + k + len / 2] = real[i + k] - tReal;
				imag[i + k + len / 2] = imag[i + k] - tImag;
				real[i + k] += tReal;
				imag[i + k] += tImag;
				const tempReal = wReal * wlenReal - wImag * wlenImag;
				const tempImag = wReal * wlenImag + wImag * wlenReal;
				wReal = tempReal;
				wImag = tempImag;
			}
		}
	}
}

class Spectrogram {
	constructor(audioBuffer, frameLength = 2048, frameStep = 2048) {
		this.audioBuffer = audioBuffer;
		this.frameLength = frameLength;
		this.frameStep = frameStep;
		this.numBins = frameLength / 2;
		this.numFrames = Math.max(1, Math.floor((audioBuffer.length - frameLength) / frameStep) + 1);
	}

	averageChannels() {
		const numChannels = this.audioBuffer.numberOfChannels;
		if(numChannels == 1) return this.audioBuffer.getChannelData(0);

		const length = this.audioBuffer.length;
		const waveform = new Float32Array(length);
		for (let c = 0; c < numChannels; c++) {
			const channelData = this.audioBuffer.getChannelData(c);
			for (let i = 0; i < length; i++) {
				waveform[i] += channelData[i] / numChannels;
			}
		}
		return waveform;
	}

	compute() {
		const waveform = this.averageChannels();

		const hann = new Float32Array(this.frameLength).map(
			(_, i) => 0.5 * (1 - Math.cos(2 * Math.PI * i / (this.frameLength - 1))));
		const real = new Float32Array(this.frameLength);
		const imag = new Float32Array(this.frameLength);
		this.data = new Array(this.numFrames);

		for (let f = 0; f < this.numFrames; f++) {
			for (let i = 0; i < this.frameLength; i++) {
				const sampleIndex = f * this.frameStep + i;
				real[i] = (sampleIndex < waveform.length ? waveform[sampleIndex] : 0) * hann[i];
				imag[i] = 0;
			}
			fft(real, imag);
			const mag = new Float32Array(this.numBins);
			for (let i = 0; i < this.numBins; i++) {
				mag[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
			}
			this.data[f] = mag;
		}

		// Compute dB values and find min/max dB
		const epsilon = 1e-10;
		let min_db = Infinity;
		let max_db = -Infinity;
		for (let f = 0; f < this.numFrames; f++) {
			for (let i = 0; i < this.numBins; i++) {
				const db = 20 * Math.log10(this.data[f][i] + epsilon);
				min_db = Math.min(min_db, db);
				max_db = Math.max(max_db, db);
			}
		}

		// Clip min_db to a reasonable dynamic range (e.g., 80 dB below max)
		min_db = Math.max(min_db, max_db - 80);

		const low_boost = 1.0;
		const high_boost = 5.0;

		for (let f = 0; f < this.numFrames; f++) {
			for (let i = 0; i < this.numBins; i++) {
				let db = 20 * Math.log10(this.data[f][i] + epsilon);

				let v = (db - min_db) / (max_db - min_db);

				v = Math.pow(v, 13) * 50; // Custom thing: make contrast higher

				const freq_frac = i / (this.numBins - 1);
				const boost = low_boost + (high_boost - low_boost) * freq_frac;

				v *= boost; // Custom thing 2
				v = v * 255;

				if (v > 255) v = 255;
				if (v < 0) v = 0;
				this.data[f][i] = v;
			}
		}
	}

	compress(factor = 4) {
		const compressedFrames = Math.ceil(this.numFrames / factor);
		const compressedSpectrogram = new Array(compressedFrames);

		for (let f = 0; f < compressedFrames; f++) {
			const mag = new Float32Array(this.numBins).fill(0);
			const frameCount = Math.min(factor, this.numFrames - f * factor);
			for (let i = 0; i < frameCount; i++) {
				const frameIdx = f * factor + i;
				if (frameIdx < this.numFrames) {
					for (let b = 0; b < this.numBins; b++) {
						mag[b] += this.data[frameIdx][b];
					}
				}
			}
			for (let b = 0; b < this.numBins; b++) {
				mag[b] /= frameCount;
			}
			compressedSpectrogram[f] = mag;
		}

		this.data = compressedSpectrogram;
		this.numFrames = compressedFrames;
	}
}

class LeftScrollingTexture {
	constructor(w, h) {
		this.w = w;
		this.h = h;
		this.data = new Uint8Array(w * h * 4);
		this.texture = new THREE.DataTexture(this.data, w, h, THREE.RGBAFormat);
		this.texture.needsUpdate = true;

		this.currentOffset = 0;
	}

	update(newOffset, fromData) {
		if (newOffset === this.currentOffset) return;
		
		const shift = newOffset - this.currentOffset;
		this.currentOffset = newOffset;

		if (shift > 0) {
			this.data.copyWithin(0, shift * 4, this.w * this.h * 4);
			for (let x = 0; x < shift; x++) {
				const col = newOffset + shift - x;
				const baseIndex = (this.w - 1 - x) * 4;

				if(col >= 0 && col < fromData.length) {
					for (let y = 0; y < this.h; y++) {
						
						const index = (y * this.w * 4) + baseIndex;
						this.data[index] = this.data[index + 1] = this.data[index + 2] = fromData[col][y];
						this.data[index + 3] = 255;
					}
				}
			}
		}
		this.texture.needsUpdate = true;
	}
}

class Background {
	constructor(audioBuffer) {

		this.spectrogram = new Spectrogram(audioBuffer);
		this.spectrogram.compute();
		this.spectrogram.compress();

		this.texture = new LeftScrollingTexture(128, 128);

		// random RGB colors
		const colors = Array(16).fill().map(() => new THREE.Vector3(1, 1, 1));

		for(let i = 0; i < colors.length; ++i) {
			//const c = HSVtoRGB(i / colors.length, 1, 1);
			const c = HSVtoRGB(Math.random(), 1, 1);
			colors[i] = new THREE.Vector3(c.r, c.g, c.b);
		}

		this.geometry = new THREE.PlaneGeometry(20, 20);
		this.material = new THREE.ShaderMaterial({
			uniforms: {
				tex: { value: this.texture.texture },
				frac: { value: 0.0 },
				iResolution: { value: new THREE.Vector2(
					window.innerWidth * window.devicePixelRatio,
					window.innerHeight * window.devicePixelRatio) },
				colors: { value: colors }
			},
			vertexShader: `
						varying vec2 vUv;
						void main() {
							vUv = uv;
							gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
						}`,
			fragmentShader: `
						uniform sampler2D tex;
						uniform float frac;
						uniform vec3 colors[16];
						varying vec2 vUv;

						void main() {
							float colWidth = 1.0 / 128.0;
							vec2 uv = vec2(vUv.x + frac * colWidth, vUv.y);
							vec4 c = texture2D(tex, uv);
							float t = vUv.y * 4.0;
							int i0 = int(floor(t));
							int i1 = i0 + 1;
							float fracT = fract(t);
							vec3 rgb = mix(colors[i0], colors[i1], fracT) * c.r;
							
							const float edgeWidth = 0.15;
							vec2 pip = fract(uv / colWidth);

							float ax = smoothstep(0.0, edgeWidth, pip.x) * smoothstep(0.0, edgeWidth, 1.0 - pip.x);
							float ay = smoothstep(0.0, edgeWidth, pip.y) * smoothstep(0.0, edgeWidth, 1.0 - pip.y);

							float a = ax * ay;
							gl_FragColor = vec4(rgb * a, 1.0);
						}`
		});
		this.mesh = new THREE.Mesh(this.geometry, this.material);
		//this.mesh.renderOrder = 0;
	}

	setFractionalOffset(o) { this.material.uniforms.frac.value = o; }
	updateTexture(newOffset) { this.texture.update(newOffset, this.spectrogram.data); }
	getTexture() { return this.texture; }
	getNumFrames() { return this.spectrogram.numFrames; }
}

class Laser {
	constructor(color = 0xff00, width = 0.2) {
		this.width = width;
		
		const geometry = new THREE.PlaneGeometry(width, 1);
		const material = new THREE.MeshBasicMaterial({ color : color, side: THREE.DoubleSide });
		this.mesh = new THREE.Mesh(geometry, material);

		this.mesh.visible = false;
		this.mesh.renderOrder = 10;
	}

	on(start, end) {
		const direction = end.clone().sub(start);
		const length = direction.length();

		this.mesh.scale.set(this.width, length, 1);
		this.mesh.position.copy(start.clone().add(direction.multiplyScalar(0.5)));

		const angle = Math.atan2(direction.x, -direction.y);
		this.mesh.rotation.set(0, 0, angle);

		this.mesh.visible = true;
	}

	off() {
		this.mesh.visible = false;
	}
}

function createEquilateralPolygon(sides, radius, rotate) {   
	const vertices = [];
	const angleStep = (2 * Math.PI) / sides;
	for (let i = 0; i < sides; i++) {
		const angle = i * angleStep + rotate;
		vertices.push(
			radius * Math.cos(angle),
			radius * Math.sin(angle),
			0
		);
	}
	vertices.push(vertices[0], vertices[1], vertices[2]); // Close the polygon

	const indices = [];
	for (let i = 0; i < sides - 2; i++) {
		indices.push(0, i + 1, i + 2);
	}

	return { vertices: vertices, indices: indices };
}

function createEquilateralMesh(color, sides, radius, rotate = 0) {
	
	const p = createEquilateralPolygon(sides, radius, rotate);

	const geometry = new THREE.BufferGeometry();
	
	geometry.setAttribute('position', new THREE.Float32BufferAttribute(p.vertices, 3));
	geometry.setIndex(p.indices);

	const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
	material.transparent = true;
	return new THREE.Mesh(geometry, material);
}

class Entity {
	constructor(mesh, position, speed, radius) {
		this.mesh = mesh;
		this.mesh.position.copy(position ? position :  new THREE.Vector3(10, rand(-9, 9), 0));
		this.speed = speed ? speed.clone() : new THREE.Vector3(0, 0, 0);
		this.radius = radius;

		this.destroyed = false;
	}

	update(delta) {
		this.mesh.position.add(this.speed.clone().multiplyScalar(delta));
	}

	enemyUpdate(delta, autoGuidanceFactor = 1)
	{
		if(autoGuidanceFactor != 0) {
			const dir = this.player.mesh.position.clone();
			dir.sub(this.mesh.position);
			dir.normalize();
			const speed = this.speed.length();
			const targetSpeed = dir.multiplyScalar(speed);
		
			this.speed.lerp(targetSpeed, delta * autoGuidanceFactor);
		}

		this.mesh.position.add(this.speed.clone().multiplyScalar(delta));

		if (this.mesh.position.x < -10 - 0.5) {
			this.destroyed = true;
		}
		const dtp = this.mesh.position.distanceTo(this.player.mesh.position);
		if (dtp < this.radius + this.player.radius) {
			this.player.hit();
			this.destroyed = true;
		}

		if (this.health / this.maxHealth < 0.2) {
			this.health -= 0.2 * this.maxHealth * delta;
		}

		this.mesh.material.opacity = this.health / this.maxHealth;

		if (this.health <= 0) this.destroyed = true;
	}
}

class PlayerShip extends Entity {
	constructor() {
		const r = 0.5;
		const mesh = createEquilateralMesh(0xFFffFF, 3, r);
		super(mesh, new THREE.Vector3(-9.5, 0, 0), null, r);
		
		this.nextMoveTime = time.s() + 1;
		
		this.collisionCount = 0;
	}

	hit() {
		this.collisionCount++;

		this.redFlash.opacity = 0.25;
		this.redFlash.visible = true;
		
		document.getElementById('collisionCount').textContent = `Collisions: ${this.collisionCount}`;
	}

	update(delta) {
		const t = time.s();
		if(t >= this.nextMoveTime)
		{   this.nextMoveTime = t + rand(3, 5);
			
			let direction = Math.random() < 0.5 ? 1 : -1;
			if(this.mesh.position.y < -9) direction = 1;
			if(this.mesh.position.y > 9) direction = -1;

			this.speed.set(0, direction, 0);
		}

		if(this.redFlash.opacity > 0) {
			this.redFlash.opacity -= delta * 2;
			if(this.redFlash.opacity < 0) {
				this.redFlash.opacity = 0;
				this.redFlash.visible = false;
			}
		}
	}
}

class Explosion extends Entity
{
	constructor(position, speed, radius) {
		const mesh = createEquilateralMesh(0xFFFFFF, 32, 0.5);
		mesh.material.opacity = 0.25;
		//mesh.renderOrder = 1;

		super(mesh, position, speed, radius);
	}

	update(delta)
	{   super.update(delta);
		
		this.mesh.material.opacity -= delta * 0.5;
		this.mesh.scale.multiplyScalar(1 + delta * 2.0);
		this.speed.multiplyScalar(1 - delta);

		if(this.mesh.material.opacity < 0)
		{   this.mesh.material.opacity = 0;
			this.destroyed = true;
		}
	}
}

class Asteroid extends Entity {
	constructor() {
		const radius = rand(0.25, 1);
		const mesh = createEquilateralMesh(0x707070, 32, radius);

		super(mesh, null, new THREE.Vector3( - rand(0.25, 0.5), 0, 0), radius);

		this.maxHealth = this.health = rand(0.5, 3);
	}

	update(delta)
	{   super.enemyUpdate(delta, 0);
		
		this.mesh.material.opacity = 1.0; // overwrite
		const s = Math.sqrt(this.health / this.maxHealth);
		this.mesh.scale.set(s, s, 1);
	}
}

class FastEnemy extends Entity {

	constructor() {
		const r = 0.5;
		const mesh = createEquilateralMesh(0xFF0000, 3, r, Math.PI);
		super(mesh, null, new THREE.Vector3(-5, 0, 0), r);

		this.maxHealth = this.health = 0.01;
	}

	update(delta) { super.enemyUpdate(delta); }
}

class HeavyEnemy extends Entity {
	constructor() {
		const r = 0.5;
		const mesh = createEquilateralMesh(0x0000ff, 4, r, Math.PI / 4);

		super(mesh, null, new THREE.Vector3(-2, 0, 0), r);

		this.health = this.maxHealth = 1.0;
	}

	update(delta) { super.enemyUpdate(delta); }
}

class InvisibleEnemy extends Entity {
	constructor() {
		const r = 0.5;
		const mesh = createEquilateralMesh(0x0000ff, 4, r, Math.PI / 4);

		super(mesh, null, new THREE.Vector3(-0.5, 0, 0), r);

		this.maxHealth = 5.0;
		this.health = 2.0;
	}

	update(delta) { super.enemyUpdate(delta); }
}

class SineEnemy extends Entity {
	constructor() {
		const r = 0.5;
		const mesh = createEquilateralMesh(0x00ff00, 4, r);

		super(mesh, null, new THREE.Vector3(-2, 0, 0), r);

		this.health = this.maxHealth = 1.0;

		this.initialY = this.mesh.position.y;
	}

	update(delta)
	{   super.enemyUpdate(delta, 0);

		const dist = this.mesh.position.distanceTo(this.player.mesh.position);
		const maxAmplitude = 5.0;
		const minAmplitude = 1;
		const maxDistance = 20.0;
		const amplitude = minAmplitude + (maxAmplitude - minAmplitude) * (1 - Math.min(dist / maxDistance, 1));

		this.mesh.position.y = this.initialY + amplitude * Math.sin(time.s() * 5.0);
	}
}

class HexEnemy extends Entity {
	constructor(scene) {
		
		const r = 0.5;
		const mesh = createEquilateralMesh(0xF000F0, 6, r);

		super(mesh, null, new THREE.Vector3(-0.5, 0, 0), r);

		this.health = this.maxHealth = 1.0;

		const t = time.s();
		this.nextMoveTime = t + 2;
		this.nextShootTime = t + 5;
		this.nextPlayerHitTime = t + 7;

		this.scene = scene;
	}

	update(delta) {
		const t = time.s();

		if(t >= this.nextMoveTime)
		{   this.nextMoveTime = t + 2;
			
			let direction = Math.random() < 0.5 ? 1 : -1;
			if(this.mesh.position.y < -9) direction = 1;
			if(this.mesh.position.y > 9) direction = -1;

			this.speed.set(0, direction, 0);
		}
		if(t >= this.nextShootTime)
		{   if(this.laser == null)
			{   this.laser = new Laser(0xF000F0, 0.2);
				this.scene.add(this.laser.mesh);
			}
			this.laser.on(this.mesh.position, this.player.mesh.position);
		}
		if(t >= this.nextPlayerHitTime)
		{   
			this.player.hit();
			this.laser.off();

			this.nextShootTime = t + 5;
			this.nextPlayerHitTime = t + 6;
		}

		super.enemyUpdate(delta, 0);

		if(this.destroyed && this.laser)
		{   this.scene.remove(this.laser.mesh);
			this.laser = null;
		}
	}
}

class BlinkerEnemy extends Entity {
	constructor() {
		const r = 0.5;
		const mesh = createEquilateralMesh(0x00ffFF, 5, r, Math.PI);

		super(mesh, null, new THREE.Vector3(0, 0, 0), r);

		this.health = this.maxHealth = 1.0;

		this.nextBlinkTime = time.s() + 2.5;
	}

	update(delta) {
		const t = time.s();
		
		if(t > this.nextBlinkTime) {
			this.nextBlinkTime = t + 2.5;
			this.mesh.position.set(rand(-9, 9), rand(-9, 9), 0);
		}
		
		super.enemyUpdate(delta, 0);
	}
}

async function main() {
	const input = document.getElementById('audioFile');
	const canvas = document.getElementById('canvas');
	let audio, sourceNode, background, duration;

	const scene = new THREE.Scene();
	const camera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0, 10);

	function normalizedPos(clientX, clientY) {
		const x = (clientX / window.innerWidth) * 20 - 10;
		const y = - (clientY / window.innerHeight) * 20 + 10;
		return { x, y };
	}

	const renderer = new THREE.WebGLRenderer({ canvas });
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	window.addEventListener('resize', () => {
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
	});

	const playerLaser = new Laser();
	scene.add(playerLaser.mesh);

	const debugMark = new Laser(0xFFFF00, 0.5);
	debugMark.mesh.renderOrder = 100;
	debugMark.mesh.position.z = 10.5;
	scene.add(debugMark.mesh);

	const playerShip = new PlayerShip();
	scene.add(playerShip.mesh);

	const flashGeometry = new THREE.PlaneGeometry(20, 20);
	const flashMaterial = new THREE.MeshBasicMaterial({
		color: 0xff0000,
		transparent: true,
		opacity: 0.25
	});
	const redFlash = new THREE.Mesh(flashGeometry, flashMaterial);
	redFlash.visible = false;
	//redFlash.renderOrder = 20;
	scene.add(redFlash);

	playerShip.redFlash = redFlash;

	let enemies = [];
	let explosions = [];
	let asteroids = [];

	let hoveredEnemy = null;

	let lastProcessedFrame = -1;
	let lastAnimateTime = 0;

	document.addEventListener('keydown', (e) => {
		if (e.key === ' ') {
			if (audio != null) {
				if (audio.state === 'suspended') audio.resume();
				else audio.suspend();
			}
		}
	});

	function findNearest(array, x, y, currentNearest = null) {
		const markingRadius = 2;

		let minimal = Infinity;
		const xy0 = new THREE.Vector3(x, y, 0);

		if(currentNearest) {
			minimal = xy0.distanceTo(currentNearest.mesh.position);
		}

		array.forEach(a => {
			if (!a.destroyed) {
				const distance = xy0.distanceTo(a.mesh.position);
				if (distance < markingRadius && distance < minimal) {
					minimal = distance;
					currentNearest = a;
				}
			}
		});

		return currentNearest;
	}

	function handleHover(pos) {
		hoveredEnemy = findNearest(enemies, pos.x, pos.y);
		hoveredEnemy = findNearest(asteroids, pos.x, pos.y, hoveredEnemy);
	}

	canvas.addEventListener('mousemove', (e) => {
		const pos = normalizedPos(e.clientX, e.clientY);
		handleHover(pos);
	});

	canvas.addEventListener('touchmove', (e) => {
		e.preventDefault();
		if (e.touches.length > 0) {
			const touch = e.touches[0];
			const pos = normalizedPos(touch.clientX, touch.clientY);
			handleHover(pos);
		}
	});

	function spawnEnemiesFromFrame(frame) {
		if (frame < 0 || frame >= background.getNumFrames()) return;

		if(rand(0, 100) <= 1) {
			const a = new Asteroid();
			scene.add(a.mesh);
			a.player = playerShip;
			asteroids.push(a);
		}

		const spec = background.spectrogram.data[frame];
		const numBinsToCheck = 128;
		const minVal = 127;
		const maxVal = 255;
		const maxProb = 0.03;
		for (let bin = 0; bin < numBinsToCheck; bin++) {
			if (bin >= spec.length) break;
			const val = spec[bin];
			if (val < minVal) continue;
			const prob = (val - minVal) / (maxVal - minVal) * maxProb;
			if (Math.random() < prob) {
				//const y = -1 + (bin / (numBinsToCheck - 1)) * 2;
				//const position = new THREE.Vector3(10, y, 0);
				let enemy;
				const r = rand(0, 100);
				if (r < 10) {
					enemy = new InvisibleEnemy();
				}
				else if (r < 20) {
					enemy = new SineEnemy();
				}
				else if (r < 25) {
					enemy = new HexEnemy(scene);
				}
				else if (r < 30) {
					enemy = new BlinkerEnemy();
				}
				else if (r < 45) {
					enemy = new HeavyEnemy();
				}
				else {
					enemy = new FastEnemy();
				}

				enemy.player = playerShip;
				
				scene.add(enemy.mesh);
				enemies.push(enemy);
			}
		}
	}

	function animate() {
		requestAnimationFrame(animate);

		if (!sourceNode) return;
		if (audio.state !== 'running') return;

		const t = time.s();
		const delta = t - lastAnimateTime;
		lastAnimateTime = t;

		if(hoveredEnemy && hoveredEnemy.destroyed) hoveredEnemy = null;

		if (hoveredEnemy ) {
			hoveredEnemy.health -= delta;
		
			playerLaser.on(playerShip.mesh.position, hoveredEnemy.mesh.position);
		} else {
			playerLaser.off();
		}

		playerShip.update(delta);

		function removeDestroyed(array, withExplosions) {

			for (let i = array.length - 1; i >= 0; i--) {
				array[i].update(delta);
				if (!array[i].destroyed) continue;

				const entity = array[i];
				scene.remove(entity.mesh);

				if(withExplosions) {
					const x = new Explosion(entity.mesh.position, entity.speed, entity.radius)
					explosions.push(x);
					scene.add(x.mesh);
				}
			
				array.splice(i, 1);
			}
		}

		removeDestroyed(enemies, true);
		removeDestroyed(asteroids, true);
		removeDestroyed(explosions, false);

		const maxShipRadius = 0.5;

		enemies.sort((a, b) => a.mesh.position.x - b.mesh.position.x);

		let minDistSquared = Infinity;

		let nearest1 = null;
		let nearest2 = null;
		
		for (let i = 0; i < enemies.length; i++) {
			const cI = enemies[i].mesh.position;
			const rI = enemies[i].radius;

    		for (let j = i + 1; j < enemies.length; j++) {
				const cJ = enemies[j].mesh.position;
				const rJ = enemies[j].radius;

      			const distX = Math.abs(cI.x - cJ.x);

				if (distX > maxShipRadius * 2) break;

      			const distY = Math.abs(cI.y - cJ.y);
      			if (distY > maxShipRadius * 2) continue; // optional

				const distSquared = distX * distX + distY * distY;
				if (distSquared <= minDistSquared) {
        			minDistSquared = distSquared;
					nearest1 = enemies[i];
					nearest2 = enemies[j];
      			}
    		}
  		}

		if(nearest1) {
			debugMark.on(nearest1.mesh.position, nearest2.mesh.position);
		}
		else debugMark.off();


		const offset = audio.currentTime / duration * background.getNumFrames();
		const specFrame = Math.floor(offset);
		if (specFrame > lastProcessedFrame) {
			for (let frame = lastProcessedFrame + 1; frame <= specFrame; frame++) {
				spawnEnemiesFromFrame(frame);
			}
			lastProcessedFrame = specFrame;
		}
		background.setFractionalOffset(offset - specFrame);
		background.updateTexture(specFrame);

		renderer.render(scene, camera);
	}

	input.addEventListener('change', async (e) => {
		const file = e.target.files[0];
		audio = new (window.AudioContext || window.webkitAudioContext)();

		const audioBuffer = await audio.decodeAudioData(await file.arrayBuffer());
		duration = audioBuffer.duration;

		if(background != null) {
			scene.remove(background.mesh);
		}
		background = new Background(audioBuffer);
		scene.add(background.mesh);

		// Start playback automatically
		if (audio.state === 'suspended') audio.resume();

		sourceNode = audio.createBufferSource();
		sourceNode.buffer = audioBuffer;
		sourceNode.connect(audio.destination);
		sourceNode.start();

		time = new AudioTime(audio);
		
		animate();
	});
}

main();
	</script>
</body>
</html>
