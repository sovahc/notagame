<head>
    <title>Not a music game</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; color: white }
        canvas { display: block; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #debug1 {
            position: absolute;
            top: 10px;
            right: 10px;
            color: yellow;
            font-size: 24px;
            font-family: Courier;
            z-index: 10;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="ui">
        <div id="debug">Debug</div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
class ZeroTime {
		s() { return 0; }
}

class AudioTime {
	constructor(audio) { this.audio = audio; }

	s() { return this.audio.currentTime; }
}

let time = new ZeroTime();

function rand(min, max) { return min + Math.random() * (max - min); }

function clamp(v, min, max) {
	if (v < min) return min;
	if (v > max) return max;
	return v;
}

function HSVtoRGB(h, s, v) {
	var r, g, b, i, f, p, q, t;
	if (arguments.length === 1) {
		s = h.s, v = h.v, h = h.h;
	}
	i = Math.floor(h * 6);
	f = h * 6 - i;
	p = v * (1 - s);
	q = v * (1 - f * s);
	t = v * (1 - (1 - f) * s);
	switch (i % 6) {
		case 0: r = v, g = t, b = p; break;
		case 1: r = q, g = v, b = p; break;
		case 2: r = p, g = v, b = t; break;
		case 3: r = p, g = q, b = v; break;
		case 4: r = t, g = p, b = v; break;
		case 5: r = v, g = p, b = q; break;
	}
	return { r: r, g: g, b: b };
}

function fft(real, imag) {
	const n = real.length;
	if ((n & (n - 1)) !== 0) throw new Error("FFT length must be a power of 2");

	let j = 0;
	for (let i = 1; i < n; i++) {
		let bit = n >> 1;
		while (j >= bit) { j -= bit; bit >>= 1; }
		j += bit;
		if (i < j) {
			[real[i], real[j]] = [real[j], real[i]];
			[imag[i], imag[j]] = [imag[j], imag[i]];
		}
	}

	for (let len = 2; len <= n; len <<= 1) {
		const ang = -2 * Math.PI / len;
		const wlenReal = Math.cos(ang), wlenImag = Math.sin(ang);
		for (let i = 0; i < n; i += len) {
			let wReal = 1, wImag = 0;
			for (let k = 0; k < len / 2; k++) {
				const uReal = real[i + k + len / 2], uImag = imag[i + k + len / 2];
				const tReal = uReal * wReal - uImag * wImag;
				const tImag = uReal * wImag + uImag * wReal;
				real[i + k + len / 2] = real[i + k] - tReal;
				imag[i + k + len / 2] = imag[i + k] - tImag;
				real[i + k] += tReal;
				imag[i + k] += tImag;
				const tempReal = wReal * wlenReal - wImag * wlenImag;
				const tempImag = wReal * wlenImag + wImag * wlenReal;
				wReal = tempReal;
				wImag = tempImag;
			}
		}
	}
}

class Spectrogram {
	constructor(audioBuffer, frameLength = 2048, frameStep = 2048) {
		this.audioBuffer = audioBuffer;
		this.frameLength = frameLength;
		this.frameStep = frameStep;
		this.numBins = frameLength / 2;
		this.numFrames = Math.max(1, Math.floor((audioBuffer.length - frameLength) / frameStep) + 1);
	}

	averageChannels() {
		const numChannels = this.audioBuffer.numberOfChannels;
		if (numChannels == 1) return this.audioBuffer.getChannelData(0);

		const length = this.audioBuffer.length;
		const waveform = new Float32Array(length);
		for (let c = 0; c < numChannels; c++) {
			const channelData = this.audioBuffer.getChannelData(c);
			for (let i = 0; i < length; i++) {
				waveform[i] += channelData[i] / numChannels;
			}
		}
		return waveform;
	}

	compute() {
		const waveform = this.averageChannels();

		const hann = new Float32Array(this.frameLength).map(
			(_, i) => 0.5 * (1 - Math.cos(2 * Math.PI * i / (this.frameLength - 1))));
		const real = new Float32Array(this.frameLength);
		const imag = new Float32Array(this.frameLength);
		this.data = new Array(this.numFrames);

		for (let f = 0; f < this.numFrames; f++) {
			for (let i = 0; i < this.frameLength; i++) {
				const sampleIndex = f * this.frameStep + i;
				real[i] = (sampleIndex < waveform.length ? waveform[sampleIndex] : 0) * hann[i];
				imag[i] = 0;
			}
			fft(real, imag);
			const mag = new Float32Array(this.numBins);
			for (let i = 0; i < this.numBins; i++) {
				mag[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
			}
			this.data[f] = mag;
		}

		// Compute dB values and find min/max dB
		const epsilon = 1e-10;
		let min_db = Infinity;
		let max_db = -Infinity;
		for (let f = 0; f < this.numFrames; f++) {
			for (let i = 0; i < this.numBins; i++) {
				const db = 20 * Math.log10(this.data[f][i] + epsilon);
				min_db = Math.min(min_db, db);
				max_db = Math.max(max_db, db);
			}
		}

		// Clip min_db to a reasonable dynamic range (e.g., 80 dB below max)
		min_db = Math.max(min_db, max_db - 80);

		const low_boost = 1.0;
		const high_boost = 5.0;

		for (let f = 0; f < this.numFrames; f++) {
			for (let i = 0; i < this.numBins; i++) {
				let db = 20 * Math.log10(this.data[f][i] + epsilon);

				let v = (db - min_db) / (max_db - min_db);

				v = Math.pow(v, 13) * 50; // Custom thing: make contrast higher

				const freq_frac = i / (this.numBins - 1);
				const boost = low_boost + (high_boost - low_boost) * freq_frac;

				v *= boost; // Custom thing 2
				v = v * 255;

				if (v > 255) v = 255;
				if (v < 0) v = 0;
				this.data[f][i] = v;
			}
		}
	}

	compress(factor = 4) {
		const compressedFrames = Math.ceil(this.numFrames / factor);
		const compressedSpectrogram = new Array(compressedFrames);

		for (let f = 0; f < compressedFrames; f++) {
			const mag = new Float32Array(this.numBins).fill(0);
			const frameCount = Math.min(factor, this.numFrames - f * factor);
			for (let i = 0; i < frameCount; i++) {
				const frameIdx = f * factor + i;
				if (frameIdx < this.numFrames) {
					for (let b = 0; b < this.numBins; b++) {
						mag[b] += this.data[frameIdx][b];
					}
				}
			}
			for (let b = 0; b < this.numBins; b++) {
				mag[b] /= frameCount;
			}
			compressedSpectrogram[f] = mag;
		}

		this.data = compressedSpectrogram;
		this.numFrames = compressedFrames;
	}
}

class LeftScrollingTexture {
	constructor(w, h) {
		this.w = w;
		this.h = h;
		this.data = new Uint8Array(w * h * 4);
		this.texture = new THREE.DataTexture(this.data, w, h, THREE.RGBAFormat);
		this.texture.needsUpdate = true;

		this.currentOffset = 0;
	}

	update(newOffset, fromData) {
		if (newOffset === this.currentOffset) return;

		const shift = newOffset - this.currentOffset;
		this.currentOffset = newOffset;

		if (shift > 0) {
			this.data.copyWithin(0, shift * 4, this.w * this.h * 4);
			for (let x = 0; x < shift; x++) {
				const col = newOffset + shift - x;
				const baseIndex = (this.w - 1 - x) * 4;

				if (col >= 0 && col < fromData.length) {
					for (let y = 0; y < this.h; y++) {

						const index = (y * this.w * 4) + baseIndex;
						this.data[index] = this.data[index + 1] = this.data[index + 2] = fromData[col][y];
						this.data[index + 3] = 255;
					}
				}
			}
		}
		this.texture.needsUpdate = true;
	}
}

class Background {
	constructor(audioBuffer) {

		this.spectrogram = new Spectrogram(audioBuffer);
		this.spectrogram.compute();
		this.spectrogram.compress();

		this.texture = new LeftScrollingTexture(128, 128);

		// random RGB colors
		const colors = Array(16).fill().map(() => new THREE.Vector3(1, 1, 1));

		for (let i = 0; i < colors.length; ++i) {
			//const c = HSVtoRGB(i / colors.length, 1, 1);
			const c = HSVtoRGB(Math.random(), 1, 1);
			colors[i] = new THREE.Vector3(c.r, c.g, c.b);
		}

		this.geometry = new THREE.PlaneGeometry(20, 20);
		this.material = new THREE.ShaderMaterial({
			uniforms: {
				tex: { value: this.texture.texture },
				frac: { value: 0.0 },
				iResolution: {
					value: new THREE.Vector2(
						window.innerWidth * window.devicePixelRatio,
						window.innerHeight * window.devicePixelRatio)
				},
				colors: { value: colors }
			},
			vertexShader: `
						varying vec2 vUv;
						void main() {
							vUv = uv;
							gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
						}`,
			fragmentShader: `
						uniform sampler2D tex;
						uniform float frac;
						uniform vec3 colors[16];
						varying vec2 vUv;

						void main() {
							float colWidth = 1.0 / 128.0;
							vec2 uv = vec2(vUv.x + frac * colWidth, vUv.y);
							vec4 c = texture2D(tex, uv);
							float t = vUv.y * 4.0;
							int i0 = int(floor(t));
							int i1 = i0 + 1;
							float fracT = fract(t);
							vec3 rgb = mix(colors[i0], colors[i1], fracT) * c.r;
							
							const float edgeWidth = 0.15;
							vec2 pip = fract(uv / colWidth);

							float ax = smoothstep(0.0, edgeWidth, pip.x) * smoothstep(0.0, edgeWidth, 1.0 - pip.x);
							float ay = smoothstep(0.0, edgeWidth, pip.y) * smoothstep(0.0, edgeWidth, 1.0 - pip.y);

							float a = ax * ay;
							gl_FragColor = vec4(rgb * a, 1.0);
						}`
		});
		this.mesh = new THREE.Mesh(this.geometry, this.material);
	}

	setFractionalOffset(fo) { this.material.uniforms.frac.value = fo; }
	updateTexture(newOffset) { this.texture.update(newOffset, this.spectrogram.data); }
	getTexture() { return this.texture; }
	getNumFrames() { return this.spectrogram.numFrames; }
}

class Laser {
	constructor(color = 0xff00, width = 0.2) {
		this.width = width;

		const geometry = new THREE.PlaneGeometry(width, 1);
		const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
		this.mesh = new THREE.Mesh(geometry, material);

		this.mesh.visible = false;
		this.mesh.renderOrder = 10;

		this.direction = new THREE.Vector3();
	}

	on(start, end) {
		this.direction.copy(end);
		this.direction.sub(start);
		const length = this.direction.length();

		this.mesh.scale.set(this.width, length, 1);
		this.mesh.position.copy(start);
		this.mesh.position.addScaledVector(this.direction, 0.5);

		const angle = Math.atan2(this.direction.x, -this.direction.y);
		this.mesh.rotation.set(0, 0, angle);

		this.mesh.visible = true;
	}

	off() {
		this.mesh.visible = false;
	}
}

function createEquilateralPolygon(sides, radius, rotate) {
	const vertices = [];
	const angleStep = (2 * Math.PI) / sides;
	for (let i = 0; i < sides; i++) {
		const angle = i * angleStep + rotate;
		vertices.push(
			radius * Math.cos(angle),
			radius * Math.sin(angle),
			0
		);
	}
	vertices.push(vertices[0], vertices[1], vertices[2]); // Close the polygon

	const indices = [];
	for (let i = 0; i < sides - 2; i++) {
		indices.push(0, i + 1, i + 2);
	}

	return { vertices: vertices, indices: indices };
}

function createEquilateralMesh(color, sides, radius, rotate = 0) {

	const p = createEquilateralPolygon(sides, radius, rotate);

	const geometry = new THREE.BufferGeometry();

	geometry.setAttribute('position', new THREE.Float32BufferAttribute(p.vertices, 3));
	geometry.setIndex(p.indices);

	const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
	material.transparent = true;
	return new THREE.Mesh(geometry, material);
}

class Entity {
	constructor(mesh, position, vector, radius) {

		if (mesh) {
			this.mesh = mesh;
			this.mesh.position.copy(position ? position : new THREE.Vector3(10, rand(-9, 9), 0)); /// XXXXXXXXXXXXXXXXXXXXX
		}
		this.vector = vector ? vector.clone() : new THREE.Vector3(0, 0, 0);
		this.radius = radius;

		this.speed = 1.0;

		this.destroyed = false;
	}

	move(delta) {
		this.mesh.position.addScaledVector(this.vector, delta * this.speed);
	}
	
	common(delta) {
		if (this.mesh.position.x < -10 - 0.5) {
			this.destroyed = true;
		}
		const dtp = this.mesh.position.distanceTo(this.player.mesh.position);
		if (dtp < this.radius + this.player.radius) {
			this.player.hit();
			this.destroyed = true;
		}

		if (this.health / this.maxHealth < 0.2) {
			this.health -= 0.2 * this.maxHealth * delta;
		}
		if (this.health <= 0) this.destroyed = true;
	}
}

function findNearest(array, xy, inRadius = 2, currentNearest = null) {

	let minimal = Infinity;

	if (currentNearest) {
		minimal = xy.distanceTo(currentNearest.mesh.position);
	}

	array.forEach(a => {
		if (!a.destroyed) {
			const distance = xy.distanceTo(a.mesh.position);
			if (distance < inRadius && distance < minimal) {
				minimal = distance;
				currentNearest = a;
			}
		}
	});

	return currentNearest;
}

class PlayerShip extends Entity {
	constructor() {
		const r = 0.5;
		const mesh = createEquilateralMesh(0xFFffFF, 3, r);
		super(mesh, new THREE.Vector3(-9.5, 0, 0), null, r);

		this.score = 0;

		this.reset();
	}

	reset() {
		this.nextMoveTime = time.s() + 1;
	}

	hit() {
		this.score -= 100;

		this.redFlash.opacity = 0.25;
		this.redFlash.visible = true;
	}

	playerLogic(delta, avoid1, avoid2) {
		
		const t = time.s();
		if (t >= this.nextMoveTime) {

			let nearest = null;

			nearest = findNearest(avoid1, this.mesh.position, 5, nearest);		
			nearest = findNearest(avoid2, this.mesh.position, 5, nearest);

			let direction = 0;
			if(nearest != null) {
				//console.log("collision avoidance");
				this.nextMoveTime = t + 0.5;

				if(nearest.mesh.position.y < this.mesh.position.y) direction = +1;
				else direction = -1;

				if (this.mesh.position.y < -9) direction = 1;
				if (this.mesh.position.y > 9) direction = -1;
			}
			else {
				//console.log("random movement");
				this.nextMoveTime = t + 1.5;

				direction = Math.random() < 0.5 ? 1 : -1;

				if (this.mesh.position.y < -3) direction = 1;
				if (this.mesh.position.y > 3) direction = -1;
			}

			this.vector.set(0, direction, 0);
		}

		this.move(delta);

		if (this.redFlash.opacity > 0) {
			this.redFlash.opacity -= delta * 2;
			if (this.redFlash.opacity < 0) {
				this.redFlash.opacity = 0;
				this.redFlash.visible = false;
			}
		}
	}
}

class Explosion extends Entity {
	constructor(position, speed, radius) {
		const mesh = createEquilateralMesh(0xFFFFFF, 32, 0.5);
		mesh.material.opacity = 0.25;

		super(mesh, position, speed, radius);
	}

	update(delta) {
		super.move(delta);

		this.mesh.material.opacity -= delta * 0.5;
		this.mesh.scale.multiplyScalar(1 + delta * 2.0);
		this.vector.multiplyScalar(1 - delta);

		if (this.mesh.material.opacity < 0) {
			this.mesh.material.opacity = 0;
			this.destroyed = true;
		}
	}
}

class Asteroid extends Entity {
	constructor() {
		const radius = rand(0.25, 1);

		const density = Math.floor(rand(1, 8));

		const mesh = createEquilateralMesh(0x404040 + 0x101010 * density, 32, radius);

		super(mesh, null, new THREE.Vector3(- rand(0.5, 1.5), 0, 0), radius);

		this.maxHealth = this.health = 1 + density / 2;
	}

	update(delta) {
		super.move(delta);
		super.common(delta);

		this.mesh.material.opacity = 1.0; // overwrite
		const s = Math.sqrt(this.health / this.maxHealth);
		this.mesh.scale.set(s, s, 1);
	}
}

class Block {
	constructor(mesh) { this.mesh = mesh; }
	initialize(ship) {}
}

const blockR = 0.5;

class FastBlock extends Block {
	constructor() { super(createEquilateralMesh(0xFF0000, 3, blockR, Math.PI)); }

	initialize(ship) { ship.health = ship.maxHealth = 0.1; ship.speed = 2.5; ship.homing = 1; }
}

class HeavyBlock extends Block {
	constructor() { super(createEquilateralMesh(0x0000ff, 4, blockR, Math.PI / 4)); }

	initialize(ship) { ship.health = 2; ship.maxHealth = 2; ship.speed = 0.333; }
}

class InvisibleBlock extends Block {
	constructor() { super(createEquilateralMesh(0x0000ff, 4, blockR, Math.PI / 4)); }

	initialize(ship) { ship.opacityMultiplier = 0.3; }
}

class SineBlock extends Block {
	constructor() { super(createEquilateralMesh(0x00ff00, 4, blockR, 0)); }

	update(ship) {
		if(this.initialY == null) this.initialY = ship.mesh.position.y;
		
		const dtp = ship.mesh.position.distanceTo(ship.player.mesh.position);
		const maximalDistance = 20.0;
		const amplitude = 1 + 4 * (1 - Math.min(dtp / maximalDistance, 1));

		ship.mesh.position.y = this.initialY + amplitude * Math.sin(time.s() * 5.0);
	}
}

class LaserBlock extends Block {
	constructor() { super(createEquilateralMesh(0xF000F0, 6, blockR, 0));  }
	initialize(ship) { ship.shootsEvery = 5; }
}

class BlinkerBlock extends Block {
	constructor() { super(createEquilateralMesh(0x00ffFF, 5, blockR, Math.PI)); }
	initialize(ship) { ship.teleportFrequency = 0.25; }
}

class EnemyShip extends Entity {
	constructor(scene, block) {
		const group = new THREE.Group();
		group.add(block.mesh);

		super(group, null, new THREE.Vector3(-1, 0, 0), blockR);
		
		this.scene = scene;
		
		this.health = this.maxHealth = 1.0;
		this.speed = rand(0.75, 1.25);
		this.homing = 0;
		this.opacityMultiplier = 1.0;
		this.shootsEvery = -1;
		this.teleportFrequency = 0;

		block.initialize(this);

		this.blocks = [block];

		scene.add(this.mesh);
	}

	update(delta) {

		if (this.homing && this.homing > 0) {
			if (this.direction == null) this.direction = new THREE.Vector3();

			this.direction.copy(this.player.mesh.position);
			this.direction.sub(this.mesh.position);
			this.direction.normalize();
			const vl = this.vector.length();
			const targetSpeed = this.direction.multiplyScalar(vl);

			this.vector.lerp(targetSpeed, delta * this.homing);
		}

		this.move(delta);
		this.common(delta);

		this.blocks.forEach(block => { if(block.update) block.update(this); } );

		if (this.shootsEvery > 0) {

			const t = time.s();

			if (this.nextShootTime == null) {
				this.nextShootTime = t + this.shootsEvery;
				this.playerHitTime = this.nextShootTime + 2;
			}

			if (t >= this.nextShootTime) {
				if (this.laser == null) {
					this.laser = new Laser(0xF000F0, 0.2);
					this.scene.add(this.laser.mesh);
				}
				this.laser.on(this.mesh.position, this.player.mesh.position);
			}
			if (t >= this.playerHitTime) {
				this.player.hit();
				this.laser.off();

				this.nextShootTime = this.playerHitTime = null;
			}
		}

		if (this.destroyed && this.laser) {
			this.scene.remove(this.laser.mesh);
			this.laser = null;
		}

		if(this.teleportFrequency) {
			const t = time.s();

			const teleportEvery = 1 / this.teleportFrequency;
			
			if(this.nextBlinkTime == null) this.nextBlinkTime = t + teleportEvery;
		
			if (t > this.nextBlinkTime) {
				this.nextBlinkTime = t + teleportEvery;
				this.mesh.position.set(rand(-9, 9), rand(-9, 9), 0);
			}
		}
	
		const opacity = this.health / this.maxHealth * this.opacityMultiplier;
		this.mesh.children.forEach(child => child.material.opacity = opacity );
	}

	combineWith(other) {
		this.scene.remove(other.mesh);
		
		other.mesh.children.forEach(mesh => this.mesh.add(mesh));
		other.blocks.forEach(block => this.blocks.push(block));
		
		this.health += other.health;
		this.maxHealth += other.maxHealth;
		this.speed += other.speed;
		this.homing += other.homing;
		this.teleportFrequency += other.teleportFrequency;

		if(other.laser) { // fix
			this.scene.remove(other.laser.mesh);
			other.laser.mesh = null;
		}
	}
}

const LEVELS = {
    spawn: [Asteroid, FastBlock, HeavyBlock, InvisibleBlock, SineBlock, BlinkerBlock, LaserBlock ],
    levels: {
		0: [1, 100, 20, 5, 5, 1, 1], // Easy
		1: [2, 50, 20, 10, 10, 10, 10], // Every enemy
		2: [1, 500, .1, .1, .1, 5, .1], // Red attack
		3: [80, 5, 5, 5, 5, 5, 25], // Asteroid field
		4: [1, 50, 0, 0, 5, 100, 10], // Mega blink
		5: [1, 100, 1, 1, 50, 1, 5], // Green sweep
    }
};

function randomBlockClass(level) {
    const chances = LEVELS.levels[level % 6];

    for (let i = 0; i < chances.length; i++) {
        if(chances[i] > Math.random() * 1000) return LEVELS.spawn[i];
    }

    return null;
}

async function loadFile(url) {
	const response = await fetch(url);
	const total = parseInt(response.headers.get('content-length'), 10);
	let loaded = 0;

	const reader = response.body.getReader();
	const chunks = [];

	while (true) {
		const { done, value } = await reader.read();
		if (done) break;

		chunks.push(value);
		loaded += value.length;
		document.getElementById('debug').textContent = `Loading: ${Math.round((loaded / total) * 100)}%`;
	}

	return new Blob(chunks);
}

async function main() {

	const canvas = document.getElementById('canvas');

	const scene = new THREE.Scene();
	const camera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0, 10);

	const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance", });
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	window.addEventListener('resize', () => {
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
	});

	let audio, sourceNode, background, duration;

	function normalizedPos(clientX, clientY) {
		const x = (clientX / window.innerWidth) * 20 - 10;
		const y = - (clientY / window.innerHeight) * 20 + 10;
		return { x, y };
	}

	document.addEventListener('keydown', (e) => {
		if (e.key === ' ') {
			if (audio != null) {
				if (audio.state === 'suspended') audio.resume();
				else audio.suspend();
			}
		}
		else if(e.key === 'n') { levelComplete = true; } /// ???????????
	});

	canvas.addEventListener('mousemove', (e) => {
		handleHover(e.clientX, e.clientY);
	});

	canvas.addEventListener('click', (e) => {
		handleClick(e.clientX, e.clientY);
	});

	canvas.addEventListener('touchmove', (e) => {
		e.preventDefault();
		if (e.touches.length > 0) {
			const touch = e.touches[0];
			handleHover(touch.clientX, touch.clientY);
		}
	},{ passive: false });

	canvas.addEventListener('touchstart', (e) => {
		e.preventDefault();
		if (e.touches.length > 0) {
			const touch = e.touches[0];
			handleClick(touch.clientX, touch.clientY);
		}
	},{ passive: false });

	function handleHover(x, y) {
		const np = normalizedPos(x, y);

		const hoverRadius = 2;
		const xy = new THREE.Vector3(np.x, np.y, 0);
		hoveredEnemy = findNearest(enemies, xy, hoverRadius);
		hoveredEnemy = findNearest(asteroids, xy, hoverRadius, hoveredEnemy);
	}

	function handleClick(x, y) {
		if (audio != null && audio.state === 'suspended') audio.resume();
	}

	let level = 0;

	let enemies = [];
	let explosions = [];
	let asteroids = [];

	let hoveredEnemy = null;

	let lastAnimateTime = 0;
	let lastSpawnTime = 0;

	const playerLaser = new Laser();
	scene.add(playerLaser.mesh);

	const debugMark = new Laser(0xFFFF00, 0.5);
	debugMark.mesh.renderOrder = 100;
	debugMark.mesh.position.z = 10.5;
	scene.add(debugMark.mesh);

	const playerShip = new PlayerShip();
	scene.add(playerShip.mesh);

	const flashGeometry = new THREE.PlaneGeometry(20, 20);
	const flashMaterial = new THREE.MeshBasicMaterial({color: 0xff0000,transparent: true, opacity: 0.25});
	const redFlash = new THREE.Mesh(flashGeometry, flashMaterial);
	redFlash.visible = false;
	scene.add(redFlash);

	playerShip.redFlash = redFlash;

	let loadingStarted = false;
	let loadingComplete = false;
	let levelComplete = false;

	async function loadLevel() {
		
		const mp3 = './music/Level' + level + '.mp3';
		const audioBlob = await loadFile(mp3);

		audio = new (window.AudioContext || window.webkitAudioContext)();

		const arrayBuffer = await audioBlob.arrayBuffer();
		const audioBuffer = await audio.decodeAudioData(arrayBuffer);
		duration = audioBuffer.duration;

		background = new Background(audioBuffer);
		scene.add(background.mesh);

		if (audio.state === 'suspended') audio.resume();

		sourceNode = audio.createBufferSource();
		sourceNode.buffer = audioBuffer;
		sourceNode.connect(audio.destination);

		sourceNode.onended = function() { levelComplete = true; };

		sourceNode.start();

		time = new AudioTime(audio);

		// reset vars
		hoveredEnemy = null;
		lastAnimateTime = 0;
		lastSpawnTime = 0;
		playerShip.reset();
		//

        loadingComplete = true;
	}

	function nextLevel() {
		audio.suspend();
		sourceNode.stop();
        sourceNode.disconnect();
        sourceNode = null;

		levelComplete = false;
		loadingStarted = loadingComplete = false;
		++level;
	}

	requestAnimationFrame(animate);

	function animate() {
		requestAnimationFrame(animate);

		if(!loadingStarted) {
			loadingStarted = true;
			loadLevel(); // async
		}

		if(!loadingComplete) {
			renderer.render(scene, camera);
			return;
		}

		if(levelComplete) {
			nextLevel();
			return;
		}

		const t = time.s();

		const delta = t - lastAnimateTime;
		lastAnimateTime = t;

		if (hoveredEnemy && hoveredEnemy.destroyed) hoveredEnemy = null;

		if (hoveredEnemy) {
			hoveredEnemy.health -= delta;
			playerShip.score += delta;

			playerLaser.on(playerShip.mesh.position, hoveredEnemy.mesh.position);
		} else {
			playerLaser.off();
		}

		playerShip.playerLogic(delta, enemies, asteroids);

		function updateAndRemoveDestroyed(array, withExplosions) {

			for (let i = array.length - 1; i >= 0; i--) {
				array[i].update(delta);
				if (!array[i].destroyed) continue;

				const entity = array[i];
				scene.remove(entity.mesh);

				if (withExplosions) {
					const x = new Explosion(entity.mesh.position, entity.vector, entity.radius)
					explosions.push(x);
					scene.add(x.mesh);
				}

				array.splice(i, 1);
			}
		}

		updateAndRemoveDestroyed(enemies, true);
		updateAndRemoveDestroyed(asteroids, true);
		updateAndRemoveDestroyed(explosions, false);

		const searchRadius = blockR;

		enemies.sort((a, b) => a.mesh.position.x - b.mesh.position.x);

		let minDistSquared = Infinity;

		let nearest1 = -1;
		let nearest2 = -1;

		for (let i = 0; i < enemies.length; i++) {
			const cI = enemies[i].mesh.position;
			const rI = enemies[i].radius;

			for (let j = i + 1; j < enemies.length; j++) {
				const cJ = enemies[j].mesh.position;
				const rJ = enemies[j].radius;

				const distX = Math.abs(cI.x - cJ.x);

				if (distX > searchRadius * 2) break;

				const distY = Math.abs(cI.y - cJ.y);
				if (distY > searchRadius * 2) continue; // optional

				const distSquared = distX * distX + distY * distY;
				if (distSquared <= minDistSquared) {
					minDistSquared = distSquared;
					nearest1 = i;
					nearest2 = j;
				}
			}
		}

		if (nearest1 >= 0) {
			enemies[nearest1].combineWith(enemies[nearest2]);
			enemies.splice(nearest2, 1); // nearest2 > nearest1
		}

		while(t > lastSpawnTime) {
			const spawnRate = 0.1;
			lastSpawnTime += spawnRate;
			const blockClass = randomBlockClass(level);

			if(blockClass == null) continue;

			if(blockClass == Asteroid) {
				const a = new Asteroid();
				scene.add(a.mesh);
				a.player = playerShip;
				asteroids.push(a);
			}
			else {
				const enemy = new EnemyShip(scene, new blockClass());

				enemy.player = playerShip;
				enemies.push(enemy);
			}
		}

		const offset = audio.currentTime / duration * background.getNumFrames();
		const specFrame = Math.floor(offset);
		background.setFractionalOffset(offset - specFrame);
		background.updateTexture(specFrame);

		document.getElementById('debug').textContent =
			//`enemies count: ${enemies.length}`;
			`Controls: [Space] [N] [Mouse/Touch] Score: ${playerShip.score}`;

		renderer.render(scene, camera);
	}
}

main();
    </script>
</body>
</html>
